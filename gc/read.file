garbage collection(GC)

很多高级语言 偏业务 都会有垃圾回收,让开发者更关注与程序功能业务而不是内存(go java python)
有的语言没有一个标准的gc库,就需要开发者自己去关注内存的处理
但是手动释放效率又比gc自动释放内存效率要高很多

gc变化比较大的版本 gov1.3(标记清除法) v1.5(三色标记法) v1.8(三色标记法+go混合写屏障)

gc关键词:自动释放(开辟内存使用即可,释放不用开发者管) 垃圾回收 内存管理 三色标记法 STW(Stop The World)
gc的时候,全局都有很多垃圾,所以会全面停掉所有的线程,垃圾回收玩也就是释放内存后在恢复运行状态
这也正是一个优化gc的瓶颈

go的程序是运行在go运行时中的,也就是runtime包,程序编译的时候会包括runtime 线程调度等等,所以最终的可执行文件会比较大

-----------------gov1.3 标记清除法----------
比如说有一系列的需要内存的对象,可以是变量 方法 函数等等,然后之间可能互相引用调用,最初是调用者当然是我们的程序
这时如果有一个对象没有引用别人也没有被别人引用的,当然也包括程序没有引用它,也就是孤立的对象,也可以说是程序和这个对象不可达
当然也有一些被引用了的对象,但是引用过后也就是使用了然后现在不需要了,比如值拷贝,也就是和程序不可达了,这种对象也可以释放

gc过程: STW 标记不需要引用的或者说现在不需要的对象,然后释放相应的内存,然后gc完成了,线程恢复,继续运行
不断循环这些步骤,知道程序退出

这种方式比较暴力,不够好
触发gc是程序运行过程中,至于什么时候看runtime

标记清除法的缺点:STW影响性能,程序可能卡顿,还有就是要扫描全部

--------------------gov1.5三色标记法
存在白色和灰色和黑色三张表
也是从程序出发(程序的根节点)，看各个对象的引用关系，是否可达
首先全部扫描进白色表，然后遍历第一层(扫描都是只往下走一层)，扫描进灰色表(从白色表中移除)
然后遍历灰色表的节点，将可达的对象放进灰色表(从白色表中移除，放到灰色表中),然后灰色表中原本的节点移除，放进黑色表中
重复遍历灰色表的节点，直到灰色表为空，然后白色表中的就是垃圾，gc回收


扫描对象，一层

-----------------如果三色标记法未加STW的缺点-----------------
也就是gc过程中，比如我扫描了一些对象进灰色列表中，但是这个过程中被扫描的也就是黑色对象又引用了新的白色对象，但是没有将这个白色对象扫描进灰色列表中
所以问题就是gc过程中将被某个协成引用的对象给清除了(也就是为标记为灰色)
其实这里如果只是黑色在gc过程中引用了白色问题还不大，因为有可能有别的灰色之类的引用了该白色

场景是gc过程中黑色引用了某一个白色，同时该白色被某个灰色丢弃，也就是不可达
这时候就出现对象丢失的情况，那么gc就是有问题的了

解决这个问题最简单的方式就是三色标记法加STW
但是这样对性能影响又大，那这样跟gov1.3的gc的标记清除法又有什么区别呢

-----------------强三色不等式和弱三色不等式------------
解决上面说的gc错误清除，但是加STW性能消耗又大的问题
其实就是破坏其中一个条件及可(场景是gc过程中黑色引用了某一个白色，同时该白色被某个灰色丢弃，也就是不可达)
强三色不等式：强制性不予寻黑色对象引用白色对象
弱三色不等式：黑色可以引用白色，前提是存在某个灰色引用白色