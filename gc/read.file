garbage collection(GC)

很多高级语言 偏业务 都会有垃圾回收,让开发者更关注与程序功能业务而不是内存(go java python)
有的语言没有一个标准的gc库,就需要开发者自己去关注内存的处理
但是手动释放效率又比gc自动释放内存效率要高很多

gc变化比较大的版本 gov1.3(标记清除法) v1.5(三色标记法) v1.8(三色标记法+go混合写屏障)

gc关键词:自动释放(开辟内存使用即可,释放不用开发者管) 垃圾回收 内存管理 三色标记法 STW(Stop The World)
gc的时候,全局都有很多垃圾,所以会全面停掉所有的线程,垃圾回收玩也就是释放内存后在恢复运行状态
这也正是一个优化gc的瓶颈

go的程序是运行在go运行时中的,也就是runtime包,程序编译的时候会包括runtime 线程调度等等,所以最终的可执行文件会比较大

-----------------gov1.3 标记清除法----------
比如说有一系列的需要内存的对象,可以是变量 方法 函数等等,然后之间可能互相引用调用,最初是调用者当然是我们的程序
这时如果有一个对象没有引用别人也没有被别人引用的,当然也包括程序没有引用它,也就是孤立的对象,也可以说是程序和这个对象不可达
当然也有一些被引用了的对象,但是引用过后也就是使用了然后现在不需要了,比如值拷贝,也就是和程序不可达了,这种对象也可以释放

gc过程: STW 标记不需要引用的或者说现在不需要的对象,然后释放相应的内存,然后gc完成了,线程恢复,继续运行
不断循环这些步骤,知道程序退出

这种方式比较暴力,不够好
触发gc是程序运行过程中,至于什么时候看runtime

标记清除法的缺点:STW影响性能,程序可能卡顿,还有就是要扫描全部

--------------------gov1.5三色标记法
存在白色和灰色和黑色三张表
也是从程序出发(程序的根节点)，看各个对象的引用关系，是否可达
首先全部扫描进白色表，然后遍历第一层(扫描都是只往下走一层)，扫描进灰色表(从白色表中移除)
然后遍历灰色表的节点，将可达的对象放进灰色表(从白色表中移除，放到灰色表中),然后灰色表中原本的节点移除，放进黑色表中
重复遍历灰色表的节点，直到灰色表为空，然后白色表中的就是垃圾，gc回收
扫描对象，一层
新出现的白色对象要加入到白色表中

-----------------如果三色标记法未加STW的缺点-----------------
也就是gc过程中，比如我扫描了一些对象进灰色列表中，但是这个过程中被扫描的也就是黑色对象又引用了新的白色对象，但是没有将这个白色对象扫描进灰色列表中
所以问题就是gc过程中将被某个协成引用的对象给清除了(也就是为标记为灰色)
其实这里如果只是黑色在gc过程中引用了白色问题还不大，因为有可能有别的灰色之类的引用了该白色

场景是gc过程中黑色引用了某一个白色，同时该白色被某个灰色丢弃，也就是不可达
这时候就出现对象丢失的情况，那么gc就是有问题的了

解决这个问题最简单的方式就是三色标记法加STW
但是这样对性能影响又大，那这样跟gov1.3的gc的标记清除法又有什么区别呢

-----------------强三色不等式和弱三色不等式------------
解决上面说的gc错误清除，但是加STW性能消耗又大的问题
其实就是破坏其中一个条件及可(场景是gc过程中黑色引用了某一个白色，同时该白色被某个灰色丢弃，也就是不可达)
强三色不等式：强制性不允许黑色对象引用白色对象
弱三色不等式：黑色可以引用白色，前提是存在某个灰色引用白色，或者灰色引用了某个白色这个白色在引用在色，只要上游有灰色。保证灰色到白色不会断



----------------插入写屏障----------------------
满足强三色不等式

栈和堆的区别，堆的内存空间的，栈主要是对象内存地址，还有对函数地址进行压栈，这样子函数执行完才知道下一个要执行的函数
所以栈的空间较小。然后为了不影响性能，插入屏障是不在栈空间上使用的，保证栈的性能(gc不用与栈)
栈空间和堆空间可以看成栈和全局变量，栈对象可以引用堆对象，堆对象不能引用栈对象

gc是用于回收堆内存，栈内存在函数结束后就释放了

程序有栈空间和堆空间，然后又有各自的对象(go的栈动态伸缩，运行时控制，gc用于堆，堆开启了插入屏障)
go在栈上创建对象，只有发生逃逸的时候才会把对象写到堆上(栈不需要gc,出栈相当于gc了)
(栈和堆的对象可以互相引用，也因为栈对象引用了堆对象，所以gc也需要扫描栈对象，只是栈空间没有插入屏障)

所以栈空间的黑色对象引用个新的白色对象并不会被标记为灰色，可能会被gc清除
这时候解决方式就是在回收白色之前加入STW(防止又有黑色引用白色)，然后再扫描一次栈空间，同样是三色标记的流程，然后清除白色
所以插入写屏障在最后需要堆栈空间STW(10-100ms,一次上下文切换大约1ms)然后进行一次扫描，这里有个疑问就是为什么不一开始就STW呢，也就是扫描全部对象的时候，因为栈对象有可能需要引用堆对象


屏障：就是在程序运行中加入一道或者多道额外的判断机制
hook 回调 handler也是同样的思想

插入屏障就是当对象被引用是触发的机制
比如一个对象引用另外一个白色对象，那么这个白色对象成灰色对象。然后如果黑色对象引用白色对象，这时候就将白色对象标记成灰色对象


---------------------删除写屏障-----------------
满足弱三色不等式


比如扫描灰色列表节点时，灰色节点断开了下一个白色节点，那么后续的白色都是垃圾，也就是这个链路都是垃圾
删除写屏障是在对象删除对象2时将对象2标记为灰色，后续白色继续
栈空间和堆空间都可以用删除写屏障
缺点就是回收效率低，比如这个被删除的对象本来就是最后一个，删除写屏障会让他继续存活，直到最后回收，回收精度低

删除屏障就是对象被删除了触发的机制(对象1引用对象2,然后不引用了)

---------------gov1.8三色标记法和混合写屏障----------------------
主要就是针对上面两种屏障的缺点

gc开始的时候，gc优先直接扫描栈空间的对象，标记黑色(可达的对象)，之后不需要扫描，不用STW(准确点来说是对于每个goroutine进行STW，然后扫描，完成进行下一个)
gc过程中创建的栈对象也会标记为黑色
被删除的对象会被标记为灰色
添加的对象标记为灰色

结合了插入写屏障和删除写屏障的优点


栈 栈的对象其实是指向堆对象的指针，也就是引用堆对象，指针随着函数的推出而消失，但是堆对象不会

go的编译器会自动决定一个变量是放在栈还是堆，会做内存逃逸分析，如果发现变量的作用于在函数内，那么就是放栈中，反之分配到堆

混合写屏障实际上就是为了不加STW，基本上gc和程序业务同时展开

-----------------混合写屏障场景----------------
场景一：进行一次扫描，也就是栈开启了混合写屏障，标记可达的对象为黑色，然后栈空间的混合写屏障结束
到堆空间开启混合写屏障，扫描堆空间，一样，第一层，扫描到灰色，然后遍历灰色节点。如果这是栈中一个黑色对象引用队中的一个对象(比如白色，被前面扫描的灰色节点引用，也就是下一层)
那么这时候会删除前面的堆灰色节点对这个白色节点的引用，然后标记这个白色节点为灰色
后续一样的，如果这个新标记的灰色节点没有后续的引用了，也就是遍历完全部的灰色节点，gc开始清除


场景二：


