garbage collection(GC)

很多高级语言 偏业务 都会有垃圾回收,让开发者更关注与程序功能业务而不是内存(go java python)
有的语言没有一个标准的gc库,就需要开发者自己去关注内存的处理
但是手动释放效率又比gc自动释放内存效率要高很多

gc变化比较大的版本 gov1.3(标记清除法) v1.5(三色标记法) v1.8(三色标记法+go混合写屏障)

gc关键词:自动释放(开辟内存使用即可,释放不用开发者管) 垃圾回收 内存管理 三色标记法 STW(Stop The World)
gc的时候,全局都有很多垃圾,所以会全面停掉所有的线程,垃圾回收玩也就是释放内存后在恢复运行状态
这也正是一个优化gc的瓶颈

go的程序是运行在go运行时中的,也就是runtime包,程序编译的时候会包括runtime 线程调度等等,所以最终的可执行文件会比较大

-----------------gov1.3 标记清除法
比如说有一系列的需要内存的对象,可以是变量 方法 函数等等,然后之间可能互相引用调用,最初是调用者当然是我们的程序
这时如果有一个对象没有引用别人也没有被别人引用的,当然也包括程序没有引用它,也就是孤立的对象,也可以说是程序和这个对象不可达
当然也有一些被引用了的对象,但是引用过后也就是使用了然后现在不需要了,比如值拷贝,也就是和程序不可达了,这种对象也可以释放

gc过程: STW 标记不需要引用的或者说现在不需要的对象,然后释放相应的内存,然后gc完成了,线程恢复,继续运行
这种方式比较暴力,不够好