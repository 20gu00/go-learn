grpc拦截器:
可分为客户端拦截器和服务端拦截器,其实就是针对请求进行拦截并设置某些内容


grpc拦截器实现:
1.pb proto文件 protoc运行准备
2.server端拦截器实现
3.或者客户端拦截器


变长参数,本质上就是slice,可以放任意个参数进来

------------------------server端拦截器实现:
在grpc.NewServer()上:
opt:=grpc.UnaryInterceptor(interceptor)   // 一元模式拦截器
在将opt放进s:=grpc.NewServer(opt)   (opt1,opt2)

需要实现这个函数,名称自定义
// 全局变量(main函数里可行)
interceptor:=func(ctx context.Context,req interface{},info *grpc.UnaryServerInfo,handler grpc.UnaryHandler)(resp interface{},err error){
    // 拦截器逻辑
    fmt.Println("拦截到一个请求了哈哈")
    // 直接return原本的逻辑,正常运行,就是正常的grpc调用处理
    return handler(ctx,req)   // 到这里服务端拦截器设置好了,每次客户端调用服务端的方法都会打印一次这个拦截到一个请求了哈哈

}

interceptor:=func(ctx context.Context,req interface{},info *grpc.UnaryServerInfo,handler grpc.UnaryHandler)(resp interface{},err error){
    // 拦截器逻辑
    fmt.Println("拦截到一个请求了哈哈")
    // 这里可以获取个当前时间

    // 调用逻辑完成后我先不return,接收一下res,可以用来统计服务端完成的时间
    res,err:=handler(ctx,req)
    fmt.Println("请求完成")
    // 这里可以获取一个当前时间,减去之前的时间就是运行的时间(gin的中间件就是)
    return res,err   // 客户端调用以上这些内容都会打印

}

------------------------grpc的客户端拦截器实现
在grpc.Dial()之前:
interceptor:=func(ctx context.Context,method string, req,reply interface{},cc *grpc.ClientConn,invoker grpc.UnaryInvoker,opts ...grpc.CallOption)err error{
    // 拦截器逻辑
    // 本次调用总共花多少时间

    start:time.Now()
    // 调用的逻辑
    err:=involer(ctx,method,req,reply,cc,opts...)
    // time.Since()从start到现在多长时间
    fmt.Printf("时长总共%v",time.Since(start))
    return err
}
opt:=grpc.WithUnaryInterceptor(interceptor)
grpc.Dial("127.0.0.1:50051",grpc.WithInsecure(),opt)
或者:
var opts=[]grpc.DialOption
opts=append(opts,grpc.WithInsecure())
opts=append(opts,grpc.WithUnaryInterceptor(interceptor))
//传递slice
grpc.Dial("127.0.0.1:50051",opts)
然后客户端运行,会打印出fmt.Printf("时长总共%v",time.Since(start))
(总结,拦截器这些内容都会同意呗客户端使用,也就是拦截请求,做些拦截器的逻辑,而不影响调用的服务的逻辑)







go-grpc-middleware库下有很多常见的拦截器功能


















---------------------------grpc拦截器和metadata搭配使用
实现请求过来服务端,验证,用户名/密码
使用metadata而不是message可以避免调用业务逻辑的侵入性

可以在拦截器的代码中生成metadata,就是metadata的new或者Pairs的代码
拿到md,根据md做一个ctx
再到业务逻辑代码调用err:=involer(ctx,method,req,reply,cc,opts...)



server端获取metadata也在拦截器中做而不用改业务代码
就是在handler之前:
md,err:=metadata.FromIncomingContext(ctx)
1.先判断有没有metadata
2.拿到id passwd判断是否正确

对于错误,比如拦截器返回的错误可以使用grpc提供的错误status.Error(codes.grpc内置的错误码,"没有token认证的信息)  (code,msg)
"google.golang.org/grpc/status"


然后启动客户端和服务端,即可通过拦截器实现auth认证,认证失败上面的拦截器直接return,不执行handler










------------------------------更高级的grpc搭配metadata(auth验证)
客户端:
type customCredential struct{}
func (c customCredential)GetRequestMetadata(ctx context.Context,uri ...string)(map[string]string,error){
    return map[string]string{
        //metadata中定义的key-value
        "appid":"100",
        "appkey":"test ok",
    },nil
}
// 不太需要
func (c customCredential)RequireTransportSecurity()bool{
    return false
}

main:
在grpc.Dial之前
opt:=grpc.WithPerRPCCredentials(customCredential{})
将这个opt添加到opts中,也就是grpc.Dial()的参数


服务端:
写法不变,一样可以通过拦截起来做metadata解析








