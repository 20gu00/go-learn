----------------GMP-----------------
线程调度模型(并发模型CSP)
golang的线程调度器

单进程时代：单一执行流程，如果线程阻塞，cpu不释放，浪费资源

多线程/多进程操作系统：cpu可以处理多个进程，单个cpu也就是切片方式(时间切片，超过时间就强制释放cpu，多个cpu也一样，多对多
并发，如果一个进程阻塞，可以切换到另一个进程

进程的切换是要成本，cpu把cpu寄存器中的当前线程的数据保存到内存中，然后从内存中加载另一个进程的数据到cpu中
上下文切换也差不多道理，有复制数据的情况。
切换过程中也叫做cpu的浪费时间
这也正是多进程和多线程的弊端，进程越多，切换浪费就可能越大，切换成本越高，cpu可能只有百分之50的时间在处理程序进程等，百分之50在切换
线程的切换成本比进程小得多
多线程也会带来同步竞争的问题，怎么异步执行，怎么处理同步竞争的问题


一个线程分为内核空间和用户空间，那么可以分成内核线程和用户空间线程，内核线程负责底层的资源(cpu 内存)，用户线程负责程序的业务逻辑，这两个线程又一一绑定
实际上调度单位是线程，也就是内核负责调度线程
上面这个分层是go的思维，内核线程thread，用户空间线程go-routine

在两者之间可以加上一个线程调度器，线程调度器和内核线程绑定，可以有多个用户空间线程，这就是用户级线程模型
问题就是如果某个goroutine阻塞了，会影响到其他goroutine没法获取资源进行运行(线程切换的问题)

如果goroutine和thread一比一，那么线程的切换就要切换底层的thread，成本高，这就是内核级线程模型



一个进程会有一个主线程，由该线程继续开辟线程，进程获得固定大小的cpu和内存资源，由主线程往下分配