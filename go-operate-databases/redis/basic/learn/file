redis not only sql key-value数据库,用于数据库,缓存,消息队列

value支持五种数据类型,字符串string,字符串列别哦list,字符串集合sets,有序字符串集合sorted sets,哈希hash

内存断电即弃,redis可以存入磁盘

二进制安全,可以string存储图片内容

ping 查看连接是否正常
clear清空控制台

-------------string:
set k1 "v1"
get k1
keys * 列出当前库所有的key,生产慎用
FLUSHALL清空所有库内容
EXIST k1判断key是否存在
move name 1一处当前库1key为name的内容
EXPIRE k1 15 设置k1过期时间15s
ttl k1 查看key的剩余的生命时间(-2则是过期)
过期了get k1 内容为空
APPEND k1 "hhhhh" 拼接 这里是string拼接(zset拼接) 返回值是新的value的长度
STRLEN k1 获取k1的value长度
incr k1 自增1
decr 自减少1
incr k1 10自增10
decr k1 10自减10
getrange k1 0 4截取索引0到4的字符
set k1 v2替换
setrange k1 5 888从所以5开始 也就是567的替换成888
setex k1 15 v1创建的时候指定过期时间
setnx k1 v1 看存在则设置失败,不存在则设置成功

mset k1 v1 k2 v3 插入多条数据
keys *  //列出来,新设置的在下面
mget k1 k2
mset k1 v1 k3 v3 也算是原子操作,要么全部成功要么失败,存在的不创建
mset student:1:name v1 student:1:age v1 类:id:属性(开发作用明显)
student:1:name是一个key
mget student:1:name student:1:age

getset k1 v1 先get在set,先获取key k1,由则set v1
get k1

更多命令使用redis.io官网文档




---------list:

1.lpush（左插入）、lrange（查询集合）、rpush（右插入）操作
(左上右下)

lpush list v1  #新增一个集合list 插入v1
lpush list v2
LRANGE list 0 -1  #-1查询list的所有元素值(索引)(00就一行,最上面)(01上面两个)(索引从上往下)
1) "v5"  //0
2) "v4"  //1
3) "v3"
4) "v2"
5) "v1"
lpush list1 v1 v2 v3 v4 v5  #批量添加集合元素

lpush插入上面放进去,rpush插入下面放进去

##联想：这里我们是不是可以做一个，保存的记录值（如：账号密码的记录），
每次都使用lpush，老的数据永远在后面，我们每次获取 0 0 位置的元素，是不是相当于更新了
数据操作，但是数据记录还在？想要查询记录即可获取集合所有元素！

2.lpop（左移除）、rpop（右移除）操作
LRANGE list 0 -1
1) "v5"
2) "v4"
3) "v3"
4) "v2"
5) "v1"

lpop list  #从头部开始移除第一个元素
"v5"

rpop list  #从尾部开始移除第一个元素
"v1"



3.lindex（查询指定下标元素）、llen（获取列表集合长度） 操作
#lindex
127.0.0.1:6379> LRANGE list 0 -1
1) "v4"
2) "v3"
3) "v2"
127.0.0.1:6379> lindex list 1  #获取指定下标位置集合的元素，下标从0开始计数
"v3"
127.0.0.1:6379> lindex list 0
"v4"
#llen
127.0.0.1:6379> llen list  #获取指定集合的元素长度
(integer) 3



4.lrem（根据value移除指定的值）
127.0.0.1:6379> LRANGE list 0 -1
1) "v4"
2) "v3"
3) "v2"
127.0.0.1:6379> lrem list 1 v2  #移除集合list中的元素是v2的元素1个
(integer) 1
127.0.0.1:6379> LRANGE list 0 -1
1) "v4"
2) "v3"
127.0.0.1:6379> lrem list 0 v3 #移除集合list中的元素是v2的元素1个,这里的0和1效果是一致的
(integer) 1
127.0.0.1:6379> LRANGE list 0 -1
1) "v4"
127.0.0.1:6379> lpush list  v3 v2 v2 v2
(integer) 4
127.0.0.1:6379> LRANGE list 0 -1
1) "v2"
2) "v2"
3) "v2"
4) "v3"
5) "v4"
127.0.0.1:6379> lrem list 3 v2  #移除集合list中元素为v2 的‘3’个，这里的参数数量，如果实际中集合元素数量不达标，不会报错，全部移除后返回成功移除后的数量值
(integer) 3
127.0.0.1:6379> LRANGE list 0 -1
1) "v3"
2) "v4"



5.ltrim（截取元素）、rpoplpush（移除指定集合中最后一个元素到一个新的集合中）操作
#ltrim
127.0.0.1:6379> lpush list v1 v2 v3 v4
(integer) 4
127.0.0.1:6379> LRANGE list 0 -1
1) "v4"
2) "v3"
3) "v2"
4) "v1"
127.0.0.1:6379> ltrim list 1 2  #通过下标截取指定的长度，这个list已经被改变了，只剩下我们所指定截取后的元素
OK
127.0.0.1:6379> LRANGE list 0 -1  #只要ltrim的部分
1) "v3"
2) "v2"
################
#rpoplpush
127.0.0.1:6379> lpush list v1 v2 v3 v4 v5
(integer) 5
127.0.0.1:6379> LRANGE list 0 -1
1) "v5"
2) "v4"
3) "v3"
4) "v2"
5) "v1"
127.0.0.1:6379> rpoplpush list newlist  #移除list集合中的最后一个元素到新的集合newlist中，返回值是移除的最后一个元素值
"v1"
127.0.0.1:6379> LRANGE list 0 -1
1) "v5"
2) "v4"
3) "v3"
4) "v2"
127.0.0.1:6379> LRANGE newlist 0 -1  #确实存在该newlist集合并且有刚刚移除的元素，证明成功
1) "v1"


6.lset（更新）、linsert操作
#lset
127.0.0.1:6379> LRANGE list 0 -1
1) "v5"
2) "v4"
3) "v3"
4) "v2"
127.0.0.1:6379>
127.0.0.1:6379> lset list 1 newV5  #更新list集合中下标为‘1’的元素为‘newV5’
OK
127.0.0.1:6379> LRANGE list 0 -1  #查看证明更新成功
1) "v5"
2) "newV5"
3) "v3"
4) "v2"
##注意点：
127.0.0.1:6379> lset list1 0 vvvv  #如果指定的‘集合’不存在，报错
(error) ERR no such key
127.0.0.1:6379> lset list 8 vvv  #如果集合存在，但是指定的‘下标’不存在，报错
(error) ERR index out of range
########################
#linsert
127.0.0.1:6379> LRANGE list 0 -1
1) "v5"
2) "newV5"
3) "v3"
4) "v2"
127.0.0.1:6379> LINSERT list after v3 insertv3  #在集合中的‘v3’元素 ‘(after)之后’ 加上一个元素
(integer) 5
127.0.0.1:6379> LRANGE list 0 -1
1) "v5"
2) "newV5"
3) "v3"
4) "insertv3"
5) "v2"
127.0.0.1:6379> LINSERT list before v3 insertv3  #在集合中的‘v3’元素 ‘(before)之前’ 加上一个元素
(integer) 6
127.0.0.1:6379> LRANGE list 0 -1
1) "v5"
2) "newV5"
3) "insertv3"
4) "v3"
5) "insertv3"
6) "v2"



