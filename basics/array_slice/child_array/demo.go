package main

import "fmt"

func main() {
	//会创建一个容量10的底层数组
	s1 := make([]int, 0, 3) //0意味着一开始每天有任何切片元素
	s1 = append(s1, 0, 1, 2)
	//这是修改操作,前提是有对应的元素在
	//s1[0] = 0
	//s1[1] = 1
	//s1[2] = 2
	fmt.Println(s1)

	s2 := s1[0:2]
	fmt.Println(s2)
	s2[0] = 9
	//底层数组的容量
	fmt.Println(len(s2), cap(s2))
	fmt.Println(s2)
	//共享了一个底层数组
	fmt.Println(s1)

	//注意不能只是声明,还要初始化,不指定值初始化,默认类型零值
	//a1:=[10]int{}
	a1 := [3]int{1, 2, 3}
	fmt.Println(a1)
	//子切片
	s3 := a1[0:2]
	fmt.Println(s3)
	fmt.Printf("%T\n", s3)
	s3[0] = 9
	//容量是底层数组的容量,这里要注意,其实就是切片的结构决定的,切片实际上包含一个指向底层数组的指针和一个len和一个cap
	fmt.Println(len(s3), cap(s3))
	fmt.Println(s3)
	fmt.Println(a1)

	//以上是给予现有的切片或者数组创建子切片,共享一个底层数组,修改子切片就是修改上一级数组或者共享的底层数组,因为没有发生扩容,不管是父切片还是子切片,任何一个发生扩容,它对应的底层数组就改变了

	//注意这里给予数组创建出来的切片,加一个元素,底层数组还够放,没有扩容,所以会直接用原本的数组,切片加多了一个元素,数组也对应修改了一个元素,如果是两个,编译器发现超过原本数组大小,会扩容换个数组,就和原本的数组没关系了
	//也意味着给予数组创建出来的切片,容量主要是看底层数组
	s3 = append(s3, 99, 99) //int型参数
	fmt.Println(s3)
	fmt.Println(a1)

	//对于父切片来说,底层数组换了
	s1 = append(s1, 100, 100)
	s2[0] = 99
	fmt.Println(s1, s2)

	//加多两个,对于子切片来说,数组要换了
	//s2 = append(s2, 99, 99)
	//fmt.Println(s2, s1)

}
